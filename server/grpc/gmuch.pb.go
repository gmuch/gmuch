// Code generated by protoc-gen-go.
// source: server/grpc/gmuch.proto
// DO NOT EDIT!

/*
Package grpc is a generated protocol buffer package.

It is generated from these files:
	server/grpc/gmuch.proto

It has these top-level messages:
	QueryRequest
	QueryResponse
	ThreadRequest
	ThreadResponse
	Thread
	Message
	Email
	Pair
	Attachment
*/
package grpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc1 "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type QueryRequest struct {
	Query  string `protobuf:"bytes,1,opt,name=query" json:"query,omitempty"`
	Offset uint32 `protobuf:"varint,2,opt,name=offset" json:"offset,omitempty"`
	Limit  uint32 `protobuf:"varint,3,opt,name=limit" json:"limit,omitempty"`
}

func (m *QueryRequest) Reset()         { *m = QueryRequest{} }
func (m *QueryRequest) String() string { return proto.CompactTextString(m) }
func (*QueryRequest) ProtoMessage()    {}

type QueryResponse struct {
	Threads []*Thread `protobuf:"bytes,1,rep,name=threads" json:"threads,omitempty"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}

func (m *QueryResponse) GetThreads() []*Thread {
	if m != nil {
		return m.Threads
	}
	return nil
}

type ThreadRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *ThreadRequest) Reset()         { *m = ThreadRequest{} }
func (m *ThreadRequest) String() string { return proto.CompactTextString(m) }
func (*ThreadRequest) ProtoMessage()    {}

type ThreadResponse struct {
	Thread *Thread `protobuf:"bytes,1,opt,name=thread" json:"thread,omitempty"`
}

func (m *ThreadResponse) Reset()         { *m = ThreadResponse{} }
func (m *ThreadResponse) String() string { return proto.CompactTextString(m) }
func (*ThreadResponse) ProtoMessage()    {}

func (m *ThreadResponse) GetThread() *Thread {
	if m != nil {
		return m.Thread
	}
	return nil
}

type Thread struct {
	Id       string     `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Subject  string     `protobuf:"bytes,2,opt,name=subject" json:"subject,omitempty"`
	Authors  []string   `protobuf:"bytes,3,rep,name=authors" json:"authors,omitempty"`
	Messages []*Message `protobuf:"bytes,4,rep,name=messages" json:"messages,omitempty"`
}

func (m *Thread) Reset()         { *m = Thread{} }
func (m *Thread) String() string { return proto.CompactTextString(m) }
func (*Thread) ProtoMessage()    {}

func (m *Thread) GetMessages() []*Message {
	if m != nil {
		return m.Messages
	}
	return nil
}

type Message struct {
	Id       string   `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	ThreadId string   `protobuf:"bytes,2,opt,name=thread_id" json:"thread_id,omitempty"`
	Tags     []string `protobuf:"bytes,3,rep,name=tags" json:"tags,omitempty"`
	Emails   []*Email `protobuf:"bytes,4,rep,name=emails" json:"emails,omitempty"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}

func (m *Message) GetEmails() []*Email {
	if m != nil {
		return m.Emails
	}
	return nil
}

type Email struct {
	From        string        `protobuf:"bytes,1,opt,name=from" json:"from,omitempty"`
	To          []string      `protobuf:"bytes,2,rep,name=to" json:"to,omitempty"`
	Cc          []string      `protobuf:"bytes,3,rep,name=cc" json:"cc,omitempty"`
	Bcc         []string      `protobuf:"bytes,4,rep,name=bcc" json:"bcc,omitempty"`
	Subject     string        `protobuf:"bytes,5,opt,name=subject" json:"subject,omitempty"`
	Text        string        `protobuf:"bytes,6,opt,name=text" json:"text,omitempty"`
	Html        string        `protobuf:"bytes,7,opt,name=html" json:"html,omitempty"`
	Headers     []*Pair       `protobuf:"bytes,8,rep,name=headers" json:"headers,omitempty"`
	Attachments []*Attachment `protobuf:"bytes,9,rep,name=attachments" json:"attachments,omitempty"`
}

func (m *Email) Reset()         { *m = Email{} }
func (m *Email) String() string { return proto.CompactTextString(m) }
func (*Email) ProtoMessage()    {}

func (m *Email) GetHeaders() []*Pair {
	if m != nil {
		return m.Headers
	}
	return nil
}

func (m *Email) GetAttachments() []*Attachment {
	if m != nil {
		return m.Attachments
	}
	return nil
}

type Pair struct {
	Key   string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Value []string `protobuf:"bytes,2,rep,name=value" json:"value,omitempty"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}

type Attachment struct {
	Filename string  `protobuf:"bytes,1,opt,name=filename" json:"filename,omitempty"`
	Headers  []*Pair `protobuf:"bytes,2,rep,name=headers" json:"headers,omitempty"`
	Content  []byte  `protobuf:"bytes,3,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *Attachment) Reset()         { *m = Attachment{} }
func (m *Attachment) String() string { return proto.CompactTextString(m) }
func (*Attachment) ProtoMessage()    {}

func (m *Attachment) GetHeaders() []*Pair {
	if m != nil {
		return m.Headers
	}
	return nil
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc1.ClientConn

// Client API for Gmuch service

type GmuchClient interface {
	Query(ctx context.Context, in *QueryRequest, opts ...grpc1.CallOption) (*QueryResponse, error)
	Thread(ctx context.Context, in *ThreadRequest, opts ...grpc1.CallOption) (*ThreadResponse, error)
}

type gmuchClient struct {
	cc *grpc1.ClientConn
}

func NewGmuchClient(cc *grpc1.ClientConn) GmuchClient {
	return &gmuchClient{cc}
}

func (c *gmuchClient) Query(ctx context.Context, in *QueryRequest, opts ...grpc1.CallOption) (*QueryResponse, error) {
	out := new(QueryResponse)
	err := grpc1.Invoke(ctx, "/grpc.Gmuch/Query", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *gmuchClient) Thread(ctx context.Context, in *ThreadRequest, opts ...grpc1.CallOption) (*ThreadResponse, error) {
	out := new(ThreadResponse)
	err := grpc1.Invoke(ctx, "/grpc.Gmuch/Thread", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gmuch service

type GmuchServer interface {
	Query(context.Context, *QueryRequest) (*QueryResponse, error)
	Thread(context.Context, *ThreadRequest) (*ThreadResponse, error)
}

func RegisterGmuchServer(s *grpc1.Server, srv GmuchServer) {
	s.RegisterService(&_Gmuch_serviceDesc, srv)
}

func _Gmuch_Query_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(QueryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GmuchServer).Query(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func _Gmuch_Thread_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(ThreadRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GmuchServer).Thread(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Gmuch_serviceDesc = grpc1.ServiceDesc{
	ServiceName: "grpc.Gmuch",
	HandlerType: (*GmuchServer)(nil),
	Methods: []grpc1.MethodDesc{
		{
			MethodName: "Query",
			Handler:    _Gmuch_Query_Handler,
		},
		{
			MethodName: "Thread",
			Handler:    _Gmuch_Thread_Handler,
		},
	},
	Streams: []grpc1.StreamDesc{},
}
